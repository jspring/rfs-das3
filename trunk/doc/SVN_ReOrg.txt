SVN Re-Organization Ideas

Goals and Discussion

1. In the past we were project based.  Every project got its own code base.  To 
start a new project, you picked up the code from the closest old project, copied
 it to the new project, and started hacking.  This can be inefficient and error 
prone.  It's like we are always starting from scratch more or less.  I shouldn't need to hav John change wrtfiles to record different file specs for different 
projects.
2. Updates to the code for sensors in one project, never made it back to old 
projects.  John started to fix this with the creation of the /path/sens 
directory where he's been putting the code for our commonly used sensors.  I 
think we want to try to use this strategy of grouping common code elsewhere, not
 just for sensors and utility functions.
3. Backwards compatibility is non-existent.  If we start hacking on a car for 
CICAS, there's a good chance that we'll break a bunch of things for NT.  When we
 need to resurrect a demo, it's a lot of work.  However, I'm not sure that 
anything we're going to do is going to fix that, but we might be able to make 
it better.
4. Right now we have 4 cars, all with the same hardware/software, but pretty 
soon, those cars are going to start diverging.  It would be nice to somehow 
keep the cars similar enough that they can be easily swapped between projects.  
However, this sort of means keeping the cars up-to-date on all current and 
recently finished projects.  At a certain point, there's going to have to be 
shedding of backwards compatibility.
5. Right now, we do have some advantages being project oriented.  When a project
ends, you have all the stable code stored in the repository, and you don't need
 to bother with legacy when you move on to the next project.  You don't even 
need to download that old project's code.

Directory Structure
Usage
/das3	All the code common to a specific generation of DAS.  I numbered it 3 
	because I consider this our 3rd generation DAS, where the DAS is some 
	combination of computers & vehicles & software.  If somehow the system, 	through the years, diverges too much, making for backwards compatibility	between experiments impossible, you could just add a /das4.
	/doc
	/exp	Startup scripts for various experiment configurations
	/src	All of the basic features of the DAS get coded here, including a 		default mode of operation.  wrtfiles, generic tilcon screen, 
		comm with the video computer, and whatever else that's a basic 
		DAS function used by all experiments. 
	/test
	/ui
		/sounds
		/twd
	/veh	Code that is vehicle specific, such as the code needed to read 
		the vehicle's CAN data and put it into the data hub.
		/audi
		/altima
/path	Common code to almost all projects.
	/db	Data Hub Code
	/local	Utility Functions
	/sens 	Various Frequently Used Sensors
	/tilcon	PATH Tilcon Base Code
/project 	Each project would be like nt, cicas, etc.  Depending on the 
		scope of the projects, you may or may not need a /veh directory
 		layer.  Or, you may need multiple /veh layers if you had 
		multiple vehicles that ran vastly different code.  The point is			that this is project-specific code.
	/veh
		/src	Data processing code, wrtfiles (plug-ins?), ui source 
			code, project specific sensor code
		/test	Compiled Apps and project startup scripts
		/ui	UI resources
		 /sounds
		 /twd

How to Handle Write Files

Wrtfiles is the most complicated program to handle in the move, and the main 
points of the discussion include the following:

* There is a lot of commonality between experiments.  Wrtfiles still needs to 
write a-files, d-files based on the vehicle you are on, and it needs to synch 
with the video computer.  We don't want to keep copying all this functionality 
for each new experiment.

* However, we also don't want the wrtfiles code in the DAS3 directory to explode in size/complexity, or even to have to change with every new experiment.

In our discussion today, Tom had a proposed solution.  Basically, turn the 
wrtfiles in the DAS3 directory into a library containing all the common 
functionality needed, and then in each project directory, there would be 
wrtfiles wrapper that would call the library functions as needed.  

The wrtfiles wrapper in the project directory should really be of the nature of 
taking the vehicle input on the command line, and then calling a function to 
write the a-file, calling the right vehicle function to write the correct 
d-file, and then calling the functions to write the spec for any experiment 
specific data files.
